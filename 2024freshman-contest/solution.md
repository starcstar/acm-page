# 新生赛解题报告

by <span style="color: #FF8C00;">**Niolle_Semis**</span>, <span style="color: #AA00AA;">**DGME**</span>, <span style="color: #0000FF;">**AtomFirst**</span>, <span style="color: #FF8C00;">**Sgdd**</span>, <span style="color: #0000FF;">**4627488**</span>

[补题链接](https://www.luogu.com.cn/training/657361)

## A RUST

签到，这道题考察一些基本的语法，根据题意，我们不妨开一个`bool`数组，然后依次读取每个操作，先判断给定的位置是否合法（即是否在`1`到`n`之间），如果读入到`alloc`，就将对应的位置置为`true`，如果读入到`free `，就将对应的位置置为`false`，如果所在位置已经是`true`/`false`，就输出`Illegal operation`，否则输出`All operations are safe`。

**完整代码**
```cpp
<!--@include: ./std/a.cpp-->
```

## D 輪符雨
思考一下每次选取 $1 \leq i < j \leq n$ ，并进行 $a[i] + 1, a[j] - 1$ 会产生什么宏观意义上的影响：

* $\sum a$，即数组总和不变。
* 操作是不可逆的，对于操作 $(i,j)$，其可以使用的次数随着游戏的进行非严格递减（简证：如果不考虑其它数字，你如果操作无穷次，那么必然 $a[i] > a[j]$，违反保证有序的条件）。


考虑性质 2，每一次游戏的进行必然导致可用的 $(i,j)$ 对的减少，最终游戏局面必然是无法进行任何操作，且有序的形式，于是 **答案** 是：

$$ \lfloor \frac{\sum a }{n} \rfloor, \lfloor \frac{\sum a }{n} \rfloor, \dots, \lfloor \frac{\sum a }{n} \rfloor + 1, \dots, \lfloor \frac{\sum a }{n} \rfloor + 1 $$

> 即类似： `3 3 3 3 4 4` 这种形式，也有可能是 `3 3 3 3 3 3` 这种形式，根据是否总和还有剩余往后面的数字 +1

**为什么可以达到这种局面**

* 对于所有有序序列，都存在一种操作方式可以达到 **上述局面**。

很显然，这道题可以改成输出一种可能的构造方式来出题，但是作为签到题，还是简单一点好。

> 我们称类似于上述平均数，平均数，..., 平均数 + 1 的形式为 **好** 的，那么每次对于当前序列的后缀开始调整为好的，假设我们已经将 $a[i + 1, n]$ 调整为好的，设为 $b$。

> 那么对于我们下一个目标，即好的 $a[i, n]$，设为 $c$，一定有 $\forall j \in [i + 1, n], b_j \geq c_j$，那么我们可以从那些 $b_j \neq c_j$ 的位置，向 $a_i$ 贡献一个 1，从而便可以从 $b$ 转移到 $c$。

归纳多次后，便证明了上述结论。

由于每种有序序列都有方法转移到答案这种情况（把它想象成一个 DAG），而操作步骤次数必然是有限次，即使是随机往下跳，最终也能跳到答案。

**完整代码**
```cpp
<!--@include: ./std/d.cpp-->
```

## E 焚音打

> 那……能陪我组一辈子的乐队吗？

写出题意所述的操作，通过观察，我们可以发现，仅有第一盏灯最后是开的状态。因此仅有第一盏灯需要输出"YES"，其余的灯需要输出"NO"。

```cpp
void press(int x) { 
    light[x]^=1;
    for (int y=x+x;y<=n;y+=x)
        press(y);
}
for(int i=1;i<=n;i++) press(i);
```

本题的 `press` 是递归定义的，与平常所做的完全平方数类型的开关灯题不同。

考虑一个数 $a$ 的所有除自身以外的因数 $d$，参考 `press` 函数，容易发现对于每次对 $d$ 的修改后，必然会修改 $a$。

令 $\text{cnt}_i$ 表示 $i$ 被修改的次数，可以发现：

$$
\text{cnt}_i = \sum_{\substack{d \mid i \\ d \neq i}} \text{cnt}_d + 1
$$

特别地，这个加 $1$ 是因为遍历到 $d$ 时，对此的修改。

可以发现，当 $\text{cnt}_i$ 为奇数时，灯开；反之，灯灭。

1. 当 $i = 1$ 时，显然 $\text{cnt}_i = 1$，灯开。
2. 当 $i \in P$（$P$ 表示质数集合）时，$\text{cnt}_i = \text{cnt}_1 + 1 = 1 + 1 = 2$，灯灭。
3. 当 $i$ 为合数时，$\text{cnt}_i$ 为偶数，使用数学归纳法证明如下。

> **证明**
> 
> 显然，$\text{cnt}_4 = \text{cnt}_1 + \text{cnt}_2 + 1 = 1 + 2 + 1 = 4$。
> 
> 假设当前已经处理到了合数 $t$，则 $\text{cnt}_t$ 为偶数。
> 
> 考虑 $t$ 的下一个合数 $p$，由于 $(t, p)$ 范围内的数都是质数，所以
> 
> $$\text{cnt}_{t+1} = \text{cnt}_{t+2} = \cdots = \text{cnt}_{p-1} = 2$$
> 
> 对于 $p$ 的不等于 $1$ 且不等于 $p$ 的因数 $r_i$，易知 $\text{cnt}_{r_i}$ 为偶数，那么其和也是偶数。
> 
> 因此有
> 
> $$ \text{cnt}_p = \text{cnt}_1 + \sum \text{cnt}_{r_i} + 1 = 1 + \text{偶数} + 1 = \text{偶数}$$
> 故得证。
> 


综上所述，当且仅当 $k = 1$ 时，灯是亮着的。

**完整代码**
```cpp
<!--@include: ./std/e.cpp-->
```

## H Life Will Change

遍历排列 `p`，每当 `p[i]` 不等于 `i` 时，需要将 `p[i]` 与其正确位置的元素交换。直接查找每个元素的目标位置会导致 $O(n^2)$ 的复杂度。为优化查找过程，我们引入一个数组 `q`，其中 `q[p[i]] = i`，即 `q[x]` 记录值为 `x` 的元素所在位置。

这样，在遍历时，如果发现 `p[i] ≠ i`，可以通过 `q` 数组直接找到 `p[i]` 的目标位置 `j`，将 `p[i]` 与 `p[j]` 交换，并更新 `q` 数组。整个过程的复杂度从 $O(n^2)$ 降低到 $O(n)$。

**完整代码**
```cpp
<!--@include: ./std/h.cpp-->
```

## M INFINITY

给定一个字符串，每次将其最后一个字符移到最前方，形成的新串接到原串后作为下一次操作的字符串。

现询问第 N 个位置的字符。

根据数据范围，N < $10^{18}$，显然不能直接模拟，所以我们从每次操作入手。每次操作过后，字符串的长度会变为原先的两倍，因此可以使用分治算法。

分治法的核心思想是把问题分成多个子问题，分别解决并合并结果。对于这道题，我们可以利用分治来解决。

为了找到第 N 个字符，我们可以用一个 `t` 变量记录何时字符串长度超过 N，代码如下：

```cpp
while (t < n) t <<= 1;  // 位运算更快
```

根据题意可得，当第 N 个字符在长度为 t 的字符串的后半段时，前半段字符串中的第 `N - 1 - t / 2` 个字符必定与第 N 个字符相同。我们可以通过这个关系来编写如下代码：

```cpp
while (t != l) t >>= 1, n -= 1 + t;
```

但是，这段代码虽然接近正确，但还不完全。根据原操作，我们是将字符串的最后一个字符移到第一个后接到原串。因此，可以推导出如下的关系：

当 N 等于 `t / 2 + 1` 时，第 N 个字符为后半段字符串的第一个字符。对应的字符位置应为 `t / 2` 或 `N - 1`。加入特判后的代码如下：

```cpp
while (t != l) {
    t >>= 1;
    if (t + 1 == n) n = t;
    else n -= 1 + t;
}
```

使用三目运算符也可以简写成以下代码：

```cpp
while (t != l) t >>= 1, n = (t + 1 != n) ? n - 1 - t : t;
```

如果第 N 个字符位于前半段字符串中，我们不需要做任何操作，直接返回 `t / 2` 即可。

```cpp
while (t != l) {
	t >>= 1;
	if (n <= t) continue;
	if (t + 1 == n) n = t;
	else n -= 1 + t;
}
```

**完整代码**

```cpp
#include <bits/stdc++.h>
using namespace std;

long long l, n, t;

char s[55];

int main() {
	scanf("%s%lld", s + 1, &n), l = t = strlen(s + 1);
	while (t < n) t <<= 1;
	while (t != l) t >>= 1, n = n > t ? ((t + 1 != n) ? n - 1 - t : t) : n;
	putchar(s[n]);
	return 0;
}
```


## C International Chairs-Problem Contest

如果只有一个椅子，只能从小往大逐个尝试，最坏需要 $n$ 次。

若尝试 $a$ 重量椅子不坏，$b$ 重量坏，答案缩小到 $S(a,b)=\{a,a+1,a+2,...,b-1\}$ 。

对于一个椅子，从 $S(a,b)$ 缩小到精确答案最坏需 $(b-a-1)$ 次尝试。

若使用两个椅子，总次数 $cost$ 则为第一个椅子尝试次数 $cost1$ 与第二个椅子尝试次数 $cost2$ 的和。

若第一次尝试 $t_1=k$ 重量，第二次尝试 $t_2=k+(k-1)$ 重量，第 $i$ 次尝试 $t_i=k+(k-1)+...+(k-i+1)$ 重量，直到椅子损坏，并将范围缩小到 $S(t_{i-1},t_i)$ 。记第 $cost1$ 次尝试时损坏，则最坏还需要 $cost2=t_{cost1}-t_{cost1-1}+1=k-cost1$ 次尝试，最坏总次数 $cost=cost1+cost2=k$ 。

注意应满足 $t_k \ge n$，即 $k(k-1)/2 \ge n$，解得 $k=\lceil \frac{-1+\sqrt{8n+1}}{2} \rceil$ 。

**完整代码**
```cpp
<!--@include: ./std/c.cpp-->
```

## F Distortion!!

一个简单的解法是尝试所有满足 $1 \leq L \leq R \leq N$ 的 $(L, R)$ 对，找到所有可能的 $S$，并输出这些字符串和原始字符串 $S$ 中按字典序最小的一个。
这种方法可以得到正确答案，但由于存在 $N^2$ 对 $(L, R)$，且每个字符串的长度为 $N$，时间复杂度为 $\mathrm{O}(N^3)$，效率非常低。我们可以尝试缩小需要检查的对数。

首先，如果字符串 $S$ 仅由字符 `d` 组成，那么最优解是跳过操作，直接输出 $S$。接下来，假设 $S$ 中包含字符 `p`。
设 $i$ 为字符串 $S$ 中最左侧字符 `p` 的位置。定义 $g(l, r)$ 为选择 $(L, R) = (l, r)$ 后得到的字符串 $S$。

在这种情况下，有以下结论：

> 对于任何 $g(L, R)$，当 $L \neq i$ 时，总存在一个 $R'$ 使得 $g(i, R') < g(L, R)$。 $(\ast)$

我们将根据 $i$ 和 $L$ 的大小关系进行分类讨论，来证明上述结论。

1. **若 $i < L$**：比较 $g(i, i)$ 和 $g(L, R)$。这两个字符串的前 $(L-1)$ 个字符相同，但 $g(i, i)$ 和 $g(L, R)$ 的第 $L$ 个字符分别为 `d` 和 `p`，因此有 $g(i, i) < g(L, R)$。

2. **若 $i > L$**：比较 $g(i, R)$ 和 $g(L, R)$。从第 1 到第 $(L-1)$ 个字符以及从第 $(R+1)$ 到第 $N$ 个字符，这两者是相同的，因此我们关注剩余部分。根据假设，字符串 $S$ 的第 $L$ 到第 $(i-1)$ 个字符都是 `d`，设 $U$ 为长度为 $i-L$ 的全 `d` 字符串，第 $i$ 到第 $R$ 个字符的比较如下：
	- $g(i, R)$ 的第 $i$ 到第 $R$ 个字符为 $U + f(T)$。
	- $g(L, R)$ 的第 $i$ 到第 $R$ 个字符为 $f(U + T) = f(T) + f(U)$。

现在考虑 $U + f(T)$ 和 $f(T) + f(U)$，比较其中 `p` 的最左位置（因为字符串长度相同，只需比较最左侧不同位置即可确定哪个字符串更小）。

我们将根据 $f(T)$ 是否包含 `p` 分情况讨论：

1. **若 $f(T)$ 不包含 `p`**：$U + f(T)$ 仅由 `d` 组成且不包含 `p`，而 $f(U)$ 全由 `p` 组成，因此 $f(T) + f(U)$ 的第 $(|T| + 1)$ 个字符是 `p`，所以 $U + f(T) < f(T) + f(U)$。
2. **若 $f(T)$ 中最左侧的 `p` 在位置 $j$**：$U + f(T)$ 中 `p` 的最左位置是 $|U| + j$，而 $f(T) + f(U)$ 的最左位置是 $j$，因此 $U + f(T) < f(T) + f(U)$。

因此在所有情况下，$U + f(T) < f(T) + f(U)$ 成立，所以在情况 2 中也有 $g(i, R) < g(L, R)$。

综上所述，$(\ast)$ 在所有情况下都成立。因此，只需检查满足 $L = i$ 的 $(L, R)$ 对即可，因为对于任何 $g(L, R)$（$L \neq i$），总能找到一个更小的字符串 $g(i, R')$。

由此可见，我们需要检查的字符串数量从 $\mathrm{O}(N^2)$ 降低到 $\mathrm{O}(N)$，整体复杂度为 $\mathrm{O}(N^2)$，这已经足够高效。

**完整代码**
```cpp
<!--@include: ./std/f.cpp-->
```


## J 空の箱

经典二分答案套路，面对**最小值最大化**的问题，可以按照以下步骤进行二分：

1. 设定二分的初始范围 $[l, r]$，其中 $x$ 表示当前二分到的最小值。
2. 将目标最小值设为 $x$，然后尽可能多地将原序列拆分成若干个权值和大于等于 $x$ 的区间。
3. 判断拆分出来的区间数量是否大于等于 $m$：

   - 如果区间数量 $\geq m$，说明 $x$ 是一个合法的最小值，此时答案在 $[x, r]$ 中。
   - 如果区间数量 $< m$，说明 $x$ 过大，此时答案在 $[l, x - 1]$ 中。

4. 继续二分，直到区间收敛，得到最终答案。

**完整代码**
::: code-group
```cpp [C++]
<!--@include: ./std/j.cpp-->
```

```rust [Rust]
<!--@include: ./std/j.rs-->
```
:::

## L 视野一隅

$O(n^3)$做法：就是01背包，设$dp[i][j]$表示前i个数中选择的区间长度为j的最大价值

状态转移方程为

$$dp[i][j]=max\set{\max\limits_{k=1}^{j}\set{dp[i-k][j-k]+abs(b_i-a_{j-k+1})},dp[i-1][j]}$$

有$O(n^2)$做法，有兴趣可以问出题人 <span style="color: #FF8C00;">**Niolle_Semis**</span> qwq 

**完整代码**

::: code-group
```cpp [C++]
<!--@include: ./std/l.cpp-->
```

```rust [Rust]
<!--@include: ./std/l.rs-->
```
:::

## B CF与睡眠与蓝色星球

**在线做法**

二分区间右端点位置，并使用RMQ得到区间最小值，判断是否大于等于 $k$

时间复杂度 $O(m\log n+n\log n)$ ，前者是查询，后者是预处理ST表

**离线做法**

将所有查询区间按照 $k$ 由大到小排序

之后依次将大于等于当前查询区间 $k$ 值的位置加入树状数组中，树状数组维护一个后缀最小值即可

时间复杂度 $O(m\log n + n\log n)$

**完整代码**
```cpp
<!--@include: ./std/b.cpp-->
```

## G 名無声

由于对于每节课不能去上的概率是均等的，所以每节课翘掉的概率都是$\frac kn$

答案就是$\frac kn\sum\limits_{i=1}^n\frac{a_i}{b_i}$

**完整代码**
```cpp
<!--@include: ./std/g.cpp-->
```

## K Savourons les moments

首先考虑如何让一个序列的最大众数为 $k$ ，假设 $k$ 出现了 $x$ 次，那么 $[0, k - 1]$ 每个数出现次数不能超过 $x$ 次，$[k + 1, 5000]$ 每个数出现次数不能超过 $x - 1$ 次

令 $cnt_i$ 表示 $i$ 的出现次数，那么可以枚举 $k$ 的出现次数，出现 $x$ 次的答案即为 
 $$\binom{cnt_k}{x} \times \prod_{i = 1}^{k - 1}(\sum_{j = 0}^{min\{cnt_i, x\}}\binom{cnt_i}{j}) \times \prod_{i = k + 1}^{5000}(\sum_{j = 0}^{min\{cnt_i, x - 1\}}\binom{cnt_i}{j})$$

利用前缀和即可在 $O(n^2)$ 内计算。

注意到当 $x$ 超过 $cnt_i$ 时，$i$ 对应的贡献不会再发生变化，每当增加 $x$ 时，只更新 $cnt_i \geq x$ (或 $cnt_i > x$) 部分的值，每张照片最多会产生一次更新。

时间复杂度 $O(n)$

模意义下组合数这里提供两种方法：

- 令杨辉三角首行为第 0 行，首列为第 0 列，第 $i$ 行第 $j$ 列的值即为 $\binom{i}{j}$
- 利用exgcd或快速幂求逆元，预处理前缀\后缀积后计算

**完整代码**
```cpp
<!--@include: ./std/k.cpp-->
```

## I 若成为星座

容斥问题，总方案数为
$$S_0=(A-a_1+1)\times(A-a_2+1)\times(B-b_1+1)\times(B-b_2+1)$$

行不相交的方案数为
$$S_1=A_{A-a_1-a_2+2}^2\times (B-b_1+1)\times(B-b_2+1)$$

列不相交的方案数为
$$S_2=A_{B-b_1-b_2+2}^2\times (A-a_1+1)\times(A-a_2+1)$$

行列都不交的方案数为
$$S_3=A_{B-b_1-b_2+2}^2\times A_{A-a_1-a_2+2}^2$$

答案即为
$$S_1+S_2-S_3$$

**完整代码**
```cpp
<!--@include: ./std/i.cpp-->
```